
#define NEEDS_UPDATE(x) (x != position_number ? (x = position_number, 1) : 0)
/* Position numbers for which various examinations were last made. */
static int worms_examined = -1;
static int initial_influence_examined = -1;
static int dragons_examined_without_owl = -1;
static int dragons_examined = -1;
static int initial_influence2_examined = -1;
static int dragons_refinedly_examined = -1;
static int dragon2_initialized;
static int lively_white_dragons;
static int lively_black_dragons;
/* Initialize the dragon2[] array. */
static void
initialize_supplementary_dragon_data(void)
{
  int str;
  int d;
  int origin;
  
  /* Give each dragon (caves excluded) an id number for indexing into
   * the dragon2 array. After this the DRAGON2 macro can be used.
   */
  number_of_dragons = 0;
  for (str = BOARDMIN; str < BOARDMAX; str++) {
    if (!ON_BOARD(str))
      continue;
    origin = dragon[str].origin;
    
    if (board[str] == EMPTY)
      continue;
    
    if (dragon[origin].id == -1)
      dragon[origin].id = number_of_dragons++;
    dragon[str].id = dragon[origin].id;
  }
  
  /* Now number_of_dragons contains the number of dragons and we can
   * allocate a dragon2 array of the appropriate size. First throw
   * away the old array.
   *
   * FIXME: As a future optimization we should only allocate a new
   *       array if the old one is too small.
   */
  if (dragon2 != NULL)
    free(dragon2);
  
  dragon2 = (dragon_data2*)malloc(number_of_dragons * sizeof(*dragon2));
  gg_assert(dragon2 != NULL);
  
  /* Find the origins of the dragons to establish the mapping back to
   * the board. After this the DRAGON macro can be used.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++) {
    if (!ON_BOARD(str))
      continue;
    if (IS_STONE(board[str])
	&& dragon[str].origin == str) {
      DRAGON2(str).origin = str;
    }
  }
  
  /* Initialize the rest of the dragon2 data. */
  for (d = 0; d < number_of_dragons; d++) {
    dragon2[d].neighbors                = 0;
    dragon2[d].hostile_neighbors        = 0;

    dragon2[d].moyo_size	        = -1;
    dragon2[d].moyo_territorial_value   = 0.0;
    dragon2[d].safety                   = (dragon_status)(-1);
    dragon2[d].escape_route             = 0;
    dragon2[d].heye                     = NO_MOVE;
    dragon2[d].lunch                    = NO_MOVE;
    dragon2[d].surround_status          = 0;
    set_eyevalue(&dragon2[d].genus, 0, 0, 0, 0);

    dragon2[d].semeais                  = 0;
    dragon2[d].semeai_defense_code	= 0;
    dragon2[d].semeai_defense_point	= NO_MOVE;
    dragon2[d].semeai_attack_code	= 0;
    dragon2[d].semeai_attack_point	= NO_MOVE;
    dragon2[d].owl_attack_point         = NO_MOVE;
    dragon2[d].owl_attack_code          = 0;
    dragon2[d].owl_attack_certain       = 1;
    dragon2[d].owl_defense_point        = NO_MOVE;
    dragon2[d].owl_defense_code         = 0;
    dragon2[d].owl_defense_certain      = 1;
    dragon2[d].owl_status               = UNCHECKED;
    dragon2[d].owl_threat_status        = UNCHECKED;
    dragon2[d].owl_second_attack_point  = NO_MOVE;
    dragon2[d].owl_second_defense_point = NO_MOVE;
  }
  
  dragon2_initialized = 1;
}
 
/* Find capturable worms adjacent to each dragon. */
static void
find_lunches()
{
  int str;
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      int food;

      if (worm[str].origin != str
	  || board[str] == EMPTY
	  || worm[str].lunch == NO_MOVE)
	continue;

      food = worm[str].lunch;

      /* In contrast to worm lunches, a dragon lunch must also be
       * able to defend itself. 
       */
      if (worm[food].defense_codes[0] == 0)
	continue;

      /* Tell the move generation code about the lunch. */
      add_lunch(str, food);
	
      /* If several lunches are found, we pick the juiciest.
       * First maximize cutstone, then minimize liberties.
       */
      {
	int origin = dragon[str].origin;
	int lunch = DRAGON2(origin).lunch;

	if (lunch == NO_MOVE
	    || worm[food].cutstone > worm[lunch].cutstone
	    || (worm[food].cutstone == worm[lunch].cutstone
		&& (worm[food].liberties < worm[lunch].liberties))) {
	  DRAGON2(origin).lunch = worm[food].origin;
	  TRACE("at %1m setting %1m.lunch to %1m (cutstone=%d)\n",
		str, origin,
		worm[food].origin, worm[food].cutstone);
	}
      }
    }
}
static void
connected_to_eye_recurse(int pos, int str, int color, int eye_color,
			 struct eye_data *eye, signed char *mx,
			 signed char *me, int *halfeyes)
{
  int liberties;
  int libs[MAXLIBS];
  int r;
  int k;

  mark_string(str, mx, 1);
  liberties = findlib(str, MAXLIBS, libs);

  /* Search the liberties of (str) for eyespaces. */
  for (r = 0; r < liberties; r++) {
    if (eye[libs[r]].color == eye_color
	&& libs[r] != pos
	&& !me[eye[libs[r]].origin]) {
      me[eye[libs[r]].origin] = 1;
      *halfeyes += (min_eyes(&eye[libs[r]].value)
		    + max_eyes(&eye[libs[r]].value));
    }
  }

  if (*halfeyes >= 2)
    return;

  /* Search for new strings in the same dragon with a liberty in
   * common with (str), and recurse.
   */
  for (r = 0; r < liberties; r++) {
    if (mx[libs[r]])
      continue;
    mx[libs[r]] = 1;
    for (k = 0; k < 4; k++) {
      if (ON_BOARD(libs[r] + delta[k])
	  && board[libs[r] + delta[k]] == color
	  && is_same_dragon(str, libs[r] + delta[k])
	  && !mx[libs[r] + delta[k]])
	connected_to_eye_recurse(pos, libs[r] + delta[k], color, eye_color,
				 eye, mx, me, halfeyes);
      if (*halfeyes >= 2)
	return;
    }
  }
}
static int
connected_to_eye(int pos, int str, int color, int eye_color,
		 struct eye_data *eye)
{
  signed char mx[BOARDMAX];
  signed char me[BOARDMAX];
  int k;
  int halfeyes;

  /* mx marks strings and liberties which have already been investigated.
   * me marks the origins of eyespaces which have already been counted.
   * Start by marking (pos) and the surrounding vertices in mx.
   */
  memset(mx, 0, sizeof(mx));
  memset(me, 0, sizeof(me));
  mx[pos] = 1;
  for (k = 0; k < 8; k++)
    if (ON_BOARD(pos + delta[k]))
      mx[pos + delta[k]] = 1;

  halfeyes = 0;
  connected_to_eye_recurse(pos, str, color, eye_color, eye, mx, me, &halfeyes);

  if (halfeyes >= 2)
    return 1;
  
  return 0;
}

/* Computer two territory estimates: for *upper, the status of all
 * cricital stones gets resolved in White's favor; vice verso for
 * black.
 */
static void
compute_scores(int use_chinese_rules)
{
  signed char safe_stones[BOARDMAX];
  float strength[BOARDMAX];

  set_strength_data(WHITE, safe_stones, strength);
  compute_influence(EMPTY, safe_stones, strength, &move_influence,
      		    NO_MOVE, "White territory estimate");
  white_score = influence_score(&move_influence, use_chinese_rules);
  set_strength_data(BLACK, safe_stones, strength);
  compute_influence(EMPTY, safe_stones, strength, &move_influence,
      		    NO_MOVE, "White territory estimate");
  black_score = influence_score(&move_influence, use_chinese_rules);

  if (verbose || showscore) {
    if (white_score == black_score)
      gprintf("Score estimate: %s %f\n",
	      black_score > 0 ? "W " : "B ", gg_abs(black_score));
    else
      gprintf("Score estimate: %s %f to %s %f\n",
	      black_score > 0 ? "W " : "B ", gg_abs(black_score),
	      white_score > 0 ? "W " : "B ", gg_abs(white_score));
    fflush(stderr);
  }
}
static void
	eye_computations()
{ 
	int str;

	for (str = BOARDMIN; str < BOARDMAX; str++) {
		if (!ON_BOARD(str))
			continue;

		if (black_eye[str].color == BLACK
			&& black_eye[str].origin == str) {
				struct eyevalue value;
				int attack_point, defense_point;

				compute_eyes(str, &value, &attack_point, &defense_point, 
					black_eye, half_eye, 1);
				DEBUG(DEBUG_EYES, "Black eyespace at %1m: %s\n", str,
					eyevalue_to_string(&value));
				black_eye[str].value = value;
				propagate_eye(str, black_eye);
		}

		if (white_eye[str].color == WHITE
			&& white_eye[str].origin == str) {
				struct eyevalue value;
				int attack_point, defense_point;

				compute_eyes(str, &value, &attack_point, &defense_point,
					white_eye, half_eye, 1);
				DEBUG(DEBUG_EYES, "White eyespace at %1m: %s\n", str,
					eyevalue_to_string(&value));
				white_eye[str].value = value;
				propagate_eye(str, white_eye);
		}
	}
}
static void
analyze_false_eye_territory(void)
{
  int pos;
  int color;
  int eye_color;
  struct eye_data *eye;
  int k;

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
    
    false_eye_territory[pos] = 0;

    /* The analysis only applies to false and half eyes. */
    if (half_eye[pos].type == 0)
      continue;

    /* Determine the color of the eye. */
    if (white_eye[pos].color == WHITE) {
      color = WHITE;
      eye_color = WHITE;
      eye = white_eye;
    }
    else if (black_eye[pos].color == BLACK) {
      color = BLACK;
      eye_color = BLACK;
      eye = black_eye;
    }
    else
      continue;

    /* Make sure we have a "closed" position. Positions like
     *
     * |XXXXXX.
     * |OOOOOXX
     * |.O.O*..
     * +-------
     *
     * disqualify without further analysis. (* is a false eye vertex)
     */
    for (k = 0; k < 4; k++)
      if (ON_BOARD(pos + delta[k])
	  && board[pos + delta[k]] != color
	  && eye[pos + delta[k]].color != eye_color)
	break;
     
    if (k < 4)
      continue;

    /* Check that all adjoining strings have external connection to an
     * eye.
     */
    for (k = 0; k < 4; k++)
      if (ON_BOARD(pos + delta[k])
	  && board[pos + delta[k]] == color
	  && !connected_to_eye(pos, pos + delta[k], color, eye_color, eye))
	break;

    if (k == 4) {
      false_eye_territory[pos] = 1;
      if (0)
	gprintf("False eye territory at %1m\n", pos);
    }
  }

  /* FIXME: This initialization doesn't really belong here but must be
   *        done somewhere within examine_position().
   *        The array is eventually filled by the endgame() function.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++)
    if (ON_BOARD(pos))
      forced_backfilling_moves[pos] = 0;
}
static int
compute_escape(int pos, int dragon_status_known)
{
  int ii;
  signed char goal[BOARDMAX];
  signed char escape_value[BOARDMAX];
  signed char safe_stones[BOARDMAX];

  ASSERT1(IS_STONE(board[pos]), pos);

  for (ii = BOARDMIN; ii < BOARDMAX; ii++)
    if (ON_BOARD(ii))
      goal[ii] = is_same_dragon(ii, pos);

  /* Compute escape_value array.  Points are awarded for moyo (4),
   * area (2) or EMPTY (1).  Values may change without notice.
   */
  get_lively_stones(OTHER_COLOR(board[pos]), safe_stones);
  compute_escape_influence(board[pos], safe_stones, NULL, 0, escape_value);

  /* If we can reach a live group, award 6 points. */
  for (ii = BOARDMIN; ii < BOARDMAX; ii++) {
    if (!ON_BOARD(ii))
      continue;

    if (dragon_status_known) {
      if (dragon[ii].crude_status == ALIVE)
	escape_value[ii] = 6;
      else if (dragon[ii].crude_status == UNKNOWN
	       && (DRAGON2(ii).escape_route > 5
		   || DRAGON2(ii).moyo_size  > 5))
	escape_value[ii] = 4;
    }
    else {
      if (board[ii] == board[pos]
	  && !goal[ii]
	  && worm[ii].attack_codes[0] == 0)
	escape_value[ii] = 2;
    }
  }
  
  return dragon_escape(goal, board[pos], escape_value);
}
static enum dragon_status
compute_crude_status(int pos)
{
  /* FIXME: We lose information when constructing true_genus. This
   * code can be improved.
   */
  struct eyevalue *genus = &DRAGON2(pos).genus;
  int true_genus = max_eyes(genus) + min_eyes(genus);
  int lunch = DRAGON2(pos).lunch;

  gg_assert(dragon2_initialized);
  
  /* If it has two sure eyes, everything is just dandy. */
  if (true_genus > 3)
    return ALIVE;

  /* If the dragon consists of one worm, there is an attack, but 
   * no defense and there is less than one eye and one half eye,
   * the situation is hopeless.
   */
  if (dragon[pos].size == worm[pos].size
      && worm[pos].attack_codes[0] != 0 
      && worm[pos].defense_codes[0] == 0
      && true_genus < 3)
    return DEAD;
  
  if (lunch != NO_MOVE
      && true_genus < 3
      && worm[lunch].defense_codes[0] != 0
      && DRAGON2(pos).escape_route < 5)
    if (true_genus == 2 || worm[lunch].size > 2)
      return CRITICAL;

  if (lunch != NO_MOVE
      && true_genus >= 3)
    return ALIVE;

  if (lunch == NO_MOVE || worm[lunch].cutstone < 2) {
    if (true_genus < 3
	&& DRAGON2(pos).escape_route == 0
	&& DRAGON2(pos).moyo_size < 5)
      return DEAD;

    if (true_genus == 3
	&& DRAGON2(pos).escape_route < 5)
      return CRITICAL;
  }

  if (DRAGON2(pos).moyo_territorial_value > 9.99)
    return ALIVE;
  
  return UNKNOWN;
}
/* Add the dragon with id b as adjacent to a. */
static void
add_adjacent_dragon(int a, int b)
{
  int i;
  gg_assert(a >= 0 && a < number_of_dragons
	    && b >= 0 && b < number_of_dragons);
  /* If the array of adjacent dragons already is full, ignore
   * additional neighbors.
   */
  if (dragon2[a].neighbors == MAX_NEIGHBOR_DRAGONS)
    return;
  
  for (i = 0; i < dragon2[a].neighbors; i++)
    if (dragon2[a].adjacent[i] == b)
      return;

  dragon2[a].adjacent[dragon2[a].neighbors++] = b;

  if (DRAGON(a).color == OTHER_COLOR(DRAGON(b).color))
    dragon2[a].hostile_neighbors++;
}
static void
add_adjacent_dragons(int a, int b)
{
  gg_assert(a >= 0 && a < number_of_dragons
	    && b >= 0 && b < number_of_dragons);
  if (a == b)
    return;
  add_adjacent_dragon(a, b);
  add_adjacent_dragon(b, a);
}


static void
find_neighbor_dragons()
{
  int m, n;
  int pos;
  int pos2;
  int i, j;
  int d;
  int dragons[BOARDMAX];
  int distances[BOARDMAX];
  int dist;
  int k;
  int color;

  gg_assert(dragon2_initialized);
  
  /* Initialize the arrays. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (IS_STONE(board[pos])) {
      dragons[pos] = dragon[pos].id;
      distances[pos] = 0;
    }
    else if (ON_BOARD(pos)) {
      dragons[pos] = -1;
      distances[pos] = -1;
    }
  }

  /* Expand from dist-1 to dist. Break out of the loop at the end if
   * we couldn't expand anything. Never expand more than five steps.
   */
  for (dist = 1; dist <= 5; dist++) {
    int found_one = 0;
      
    for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
      if (!ON_BOARD(pos))
	continue;
    
      if (distances[pos] != dist-1 || dragons[pos] < 0)
	continue;
      
      color = DRAGON(dragons[pos]).color;
      for (k = 0; k < 4; k++) {
	pos2 = pos + delta[k];
	
	if (!ON_BOARD1(pos2))
	  continue;
	
	/* Consider expansion from (pos) to adjacent intersection
	 * (pos2).
	 */
	if (distances[pos2] >= 0 && distances[pos2] < dist)
	  continue; /* (pos2) already occupied. */

	/* We can always expand the first step, regardless of influence. */
	if (dist == 1
	    || (whose_area(INITIAL_INFLUENCE(color), pos) == color
		&& whose_area(INITIAL_INFLUENCE(color), pos2)
		   != OTHER_COLOR(color))) {
	  /* Expansion ok. Now see if someone else has tried to
	   * expand here. In that case we indicate a collision by
	   * setting the dragon number to -2.
	   */
	  if (distances[pos2] == dist) {
	    if (dragons[pos2] != dragons[pos])
	      dragons[pos2] = -2;
	  }
	  else {
	    dragons[pos2] = dragons[pos];
	    distances[pos2] = dist;
	    found_one = 1;
	  }
	}
      }
    }
    if (!found_one)
      break;
  }
  
  if (0) {
    for (m = 0; m < board_size; m++) {
      for (n = 0; n < board_size; n++)
	fprintf(stderr, "%3d", dragons[POS(m, n)]);
      fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
      
    for (m = 0; m < board_size; m++) {
      for (n = 0; n < board_size; n++)
	fprintf(stderr, "%3d", distances[POS(m, n)]);
      fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
  }

  /* Now go through dragons to find neighbors. It suffices to look
   * south and east for neighbors. In the case of a collision zone
   * where dragons==-2 we set all the neighbors of this intersection
   * as adjacent to each other.
   */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (!ON_BOARD(pos))
      continue;
    if (dragons[pos] == -2) {
      int neighbors = 0;
      int adjacent[4];

      for (k = 0; k < 4; k++) {
	pos2 = pos + delta[k];

	if (ON_BOARD1(pos2) && dragons[pos2] >= 0)
	  adjacent[neighbors++] = dragons[pos2];
      }
      for (i = 0; i < neighbors; i++)
	for (j = i+1; j < neighbors; j++)
	  add_adjacent_dragons(adjacent[i], adjacent[j]);
    }
    else if (dragons[pos] >= 0) {
      if (ON_BOARD(NORTH(pos))) {
	if (dragons[NORTH(pos)] >= 0
	    && dragons[NORTH(pos)] != dragons[pos])
	  add_adjacent_dragons(dragons[pos], dragons[NORTH(pos)]);
      }
      if (ON_BOARD(EAST(pos))) {
	if (dragons[EAST(pos)] >= 0
	    && dragons[EAST(pos)] != dragons[pos])
	  add_adjacent_dragons(dragons[pos], dragons[EAST(pos)]);
      }
    }
  }
  
  if (0) {
    for (d = 0; d < number_of_dragons; d++) {
      gprintf("dragon %d at %1m:", d, dragon2[d].origin);
      for (i = 0; i < dragon2[d].neighbors; i++)
	gprintf(" %1m(%d)", dragon2[dragon2[d].adjacent[i]].origin,
		dragon2[d].adjacent[i]);
      gprintf("\n");
    }
  }
}
static void
	identify_thrashing_dragons()
{
	int k;
	int dist;
	int last_move;
	int color;

	thrashing_dragon = 0;
	memset(thrashing_stone, 0, sizeof(thrashing_stone));

	last_move = get_last_move();
	if (last_move == NO_MOVE
		|| dragon[last_move].status != DEAD)
		return;

	thrashing_dragon = dragon[last_move].origin;
	DEBUG(DEBUG_DRAGONS, "thrashing dragon found at %1m\n", thrashing_dragon);
	mark_dragon(thrashing_dragon, thrashing_stone, 1);
	color = board[thrashing_dragon];

	for (dist = 1; dist < 5; dist++) {
		int pos;
		for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
			if (board[pos] != color
				|| dragon[pos].origin != pos
				|| thrashing_stone[pos] != dist)
				continue;

			for (k = 0; k < DRAGON2(pos).neighbors; k++) {
				int d = DRAGON2(pos).adjacent[k];
				if (DRAGON(d).color == color
					&& DRAGON(d).status == DEAD
					&& thrashing_stone[dragon2[d].origin] == 0) {
						DEBUG(DEBUG_DRAGONS,
							"neighbor at distance %d of thrashing dragon found at %1m\n",
							dist + 1, DRAGON(d).origin);
						mark_dragon(DRAGON(d).origin, thrashing_stone,
							(signed char)(dist + 1));
				}
			}
		}
	}
}
static int
dragon_invincible(int dr)
{
  struct eye_data *eye;
  int eye_color;
  int k;
  int pos;
  int strong_eyes = 0;
  int mx[BOARDMAX];
  
  ASSERT1(IS_STONE(board[dr]), dr);

  /* First look for invincible strings in the dragon. */
  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (ON_BOARD(pos) && is_same_dragon(pos, dr) && worm[pos].invincible)
      return 1;
  }

  /* Can the dragon be owl attacked? */
  if (DRAGON2(dr).owl_status != UNCHECKED && DRAGON2(dr).owl_status != ALIVE)
    return 0;
  
  /* Examine the eye spaces. */
  if (board[dr] == BLACK) {
    eye = black_eye;
    eye_color = BLACK;
  }
  else {
    eye = white_eye;
    eye_color = WHITE;
  }

  memset(mx, 0, sizeof(mx));

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    if (board[pos] == board[dr] && is_same_dragon(pos, dr)) {
      for (k = 0; k < 4; k++) {
	int pos2 = pos + delta[k];
	if (ON_BOARD(pos2)
	    && eye[pos2].color == eye_color
	    && eye[pos2].origin != NO_MOVE) {
	  if (eye[pos2].marginal
	      || is_halfeye(half_eye, pos2))
	    mx[eye[pos2].origin] = 2; /* bad eye */
	  else if (mx[eye[pos2].origin] == 0)
	    mx[eye[pos2].origin] = 1; /* good eye */
	  
	  if (board[pos2] == OTHER_COLOR(board[dr])
	      && (!attack(pos2, NULL) || find_defense(pos2, NULL)))
	    mx[eye[pos2].origin] = 2; /* bad eye */
	}
      }
    }
  }

  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
    /* Necessary to check eye margins here since the loop above only
     * considers margins which are directly adjacent to some stone of
     * the dragon.
     */
    if (mx[pos] == 1
	&& eye[pos].msize == 0)
      strong_eyes++;
  }

  if (strong_eyes >= 2)
    return 1;

  return 0;
}


/* A dragon looks inessential if it satisfies all of
 * 1. Is a single string.
 * 2. Is not owl substantial.
 *
 * FIXME: Probably need a better definition of INESSENTIAL dragons.
 *        There are cases where a string is owl insubstantial
 *        yet allowing it to be captured greatly weakens our
 *        position.
 */
static int
dragon_looks_inessential(int origin)
{
#if 0
  int d;
  int k;
#endif
  
  if (dragon[origin].size != worm[origin].size)
    return 0;

  if (owl_substantial(origin))
    return 0;

#if 0
  /* This is a proposed modification which solves 13x13:72 but
   * breaks buzco:5. It adds the two requirements:
   *
   * 3. Has no opponent neighbor with status better than DEAD.
   * 4. Has no opponent neighbor with escape value bigger than 0.
   *
   * This probably needs to be revised before it's enabled.
   */
  for (k = 0; k < DRAGON2(origin).neighbors; k++) {
    d = DRAGON2(origin).adjacent[k];
    if (DRAGON(d).color != board[origin]
	&& (DRAGON(d).status != DEAD
	    || dragon2[d].escape_route > 0))
      return 0;
  }
#endif
  
  return 1;
}
static void
revise_inessentiality()
{
  int str;
  /* Revise essentiality of critical worms. Specifically, a critical
   * worm which is adjacent to no enemy dragon with status
   * better than DEAD, is considered INESSENTIAL.
   *
   * A typical case of this is
   *
   * |.XXXX
   * |.OO.X
   * |X.O.X
   * |.OO.X
   * +-----
   *
   * However, to be able to deal with the position
   *
   * |.XXXX
   * |.OOOO
   * |..O.O
   * |X.OOO
   * |..O.O
   * +-----
   *
   * we need to extend "adjacent" to "adjacent or shares a liberty",
   * which is why we use extended_chainlinks() rather than
   * chainlinks().
   *
   * Finally, if the position above is slightly modified to
   *
   * |.XXXXX
   * |.OOOOO
   * |...O.O
   * |X..OOO
   * |...O.O
   * +------
   *
   * we have a position where the critical X stone doesn't share a
   * liberty with any string at all. Thus the revised rule is:
   *
   * A critical worm which is adjacent to or share a liberty with at
   * least one dead opponent dragon and no opponent dragon which is
   * not dead, is considered inessential.
   */

  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str)) {
      if (is_worm_origin(str, str)
	  && worm[str].attack_codes[0] != 0
	  && worm[str].defense_codes[0] != 0
	  && !worm[str].inessential) {
	int adjs[MAXCHAIN];
	int neighbors;
	int r;
	int essential = 0;
	
	neighbors = extended_chainlinks(str, adjs, 0);
	for (r = 0; r < neighbors; r++)
	  if (dragon[adjs[r]].status != DEAD) {
	    essential = 1;
	    break;
	  }

	if (!essential && neighbors > 0) {
	  DEBUG(DEBUG_WORMS, "Worm %1m revised to be inessential.\n", str);
	  worm[str].inessential = 1;
	  propagate_worm(str);
	}
      }
    }

  /* Revise essentiality of critical dragons. Specifically, a critical
   * dragon consisting entirely of inessential worms is considered
   * INESSENTIAL.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++) {
    if (ON_BOARD(str)
	&& board[str] != EMPTY
	&& dragon[str].origin == str
	&& DRAGON2(str).safety == CRITICAL) {
      int w;
      for (w = first_worm_in_dragon(str); w != NO_MOVE;
	   w = next_worm_in_dragon(w)) {
	if (!worm[w].inessential)
	  break;
      }

      if (w == NO_MOVE) {
	DEBUG(DEBUG_DRAGONS, "Dragon %1m revised to be inessential.\n", str);
	DRAGON2(str).safety = INESSENTIAL;
      }
    }
  }
}

/* This basic function finds all dragons and collects some basic information
 * about them in the dragon array.
 *
 * color is the player in turn to move. This does in no way affect the
 * information collected about the dragons, but it does affect what
 * information is passed on to the move generation code. If
 * color == EMPTY no information at all is passed on to the move generation.
 */

void 
make_dragons1(int stop_before_owl)
{
  int str;
  int d;

  dragon2_initialized = 0;
  initialize_dragon_data();
  /* Find explicit connections patterns in database and amalgamate
   * involved dragons.
   */
  memset(cutting_points, 0, sizeof(cutting_points));
  find_cuts();
  find_connections();

  /* At this time, all dragons have been finalized and we can
   * initialize the dragon2[] array. After that we can no longer allow
   * amalgamation of dragons.
   */
  initialize_supplementary_dragon_data();
  
  make_domains(black_eye, white_eye, 0);

  /* Find adjacent worms which can be easily captured: */
  find_lunches();

  /* Find topological half eyes and false eyes. */
  find_half_and_false_eyes(BLACK, black_eye, half_eye, NULL);
  find_half_and_false_eyes(WHITE, white_eye, half_eye, NULL);

  /* Compute the number of eyes, half eyes, determine attack/defense points
   * etc. for all eye spaces. */
  eye_computations();
  /* Try to determine whether topologically false and half eye points
   * contribute to territory even if the eye doesn't solidify.
   */
  analyze_false_eye_territory();

  /* Now we compute the genus. */
  for (d = 0; d < number_of_dragons; d++)
    compute_dragon_genus(dragon2[d].origin, &dragon2[d].genus, NO_MOVE);

  /* Compute the escape route measure. */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (IS_STONE(board[str]) && dragon[str].origin == str)
      DRAGON2(str).escape_route = compute_escape(str, 0);

  /* Set dragon weaknesses according to initial_influence. */
  compute_refined_dragon_weaknesses();
  for (d = 0; d < number_of_dragons; d++)
    dragon2[d].weakness_pre_owl = dragon2[d].weakness;

  /* Determine status: ALIVE, DEAD, CRITICAL or UNKNOWN */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str))
      if (dragon[str].origin == str && board[str])
	dragon[str].crude_status = compute_crude_status(str);
  
  /* We must update the dragon status at every intersection before we
   * call the owl code. This updates all fields.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str) && board[str] != EMPTY)
      dragon[str] = dragon[dragon[str].origin];
  
  find_neighbor_dragons();
  for (d = 0; d < number_of_dragons; d++) {
    dragon2[d].surround_status 
      = compute_surroundings(dragon2[d].origin, NO_MOVE, 0,
			     &(dragon2[d].surround_size));
    if (dragon2[d].surround_status == SURROUNDED) {
      dragon2[d].escape_route = 0;
      if (debug & DEBUG_DRAGONS)
	gprintf("surrounded dragon found at %1m\n", dragon2[d].origin);
    }
    else if (dragon2[d].surround_status == WEAKLY_SURROUNDED) {
      dragon2[d].escape_route /= 2;
      if (debug & DEBUG_DRAGONS)
	gprintf("weakly surrounded dragon found at %1m\n", dragon2[d].origin);
    }
  }

  if (stop_before_owl)
    return;
// 
  /* Determine life and death status of each dragon using the owl code
   * if necessary.
   */
  start_timer(2);
  for (str = BOARDMIN; str < BOARDMAX; str++)
	  if (ON_BOARD(str)) {
		  int attack_point = NO_MOVE;
		  int defense_point = NO_MOVE;
		  struct eyevalue no_eyes;
		  set_eyevalue(&no_eyes, 0, 0, 0, 0);
		  if (board[str] == EMPTY
			  || dragon[str].origin != str)
			  continue;

		  /* Some dragons can be ignored but be extra careful with big dragons. */
		  if (crude_dragon_weakness(ALIVE, &no_eyes, 0,
			  DRAGON2(str).moyo_territorial_value,
			  DRAGON2(str).escape_route - 10)
			  < 0.00001 + gg_max(0.12, 0.32 - 0.01*dragon[str].effective_size)) {
				  DRAGON2(str).owl_status = UNCHECKED;
				  DRAGON2(str).owl_attack_point  = NO_MOVE;
				  DRAGON2(str).owl_defense_point = NO_MOVE;
		  }
		  else {
			  int acode = 0;
			  int dcode = 0;
			  int kworm = NO_MOVE;
			  int owl_nodes_before = get_owl_node_counter();
//
			start_timer(3);
			  acode = owl_attack(str, &attack_point, 
				  &DRAGON2(str).owl_attack_certain, &kworm);
 //continue;
			  DRAGON2(str).owl_attack_node_count
				  = get_owl_node_counter() - owl_nodes_before;
//
			  if (acode != 0) {
				  DRAGON2(str).owl_attack_point = attack_point;
				  DRAGON2(str).owl_attack_code = acode;
				  DRAGON2(str).owl_attack_kworm = kworm;
				  if (attack_point != NO_MOVE) {
					  kworm = NO_MOVE;
					  dcode = owl_defend(str, &defense_point,
						  &DRAGON2(str).owl_defense_certain, &kworm);
					  if (dcode != 0) {
						  if (defense_point != NO_MOVE) {
							  DRAGON2(str).owl_status = (acode == GAIN ? ALIVE : CRITICAL);
							  DRAGON2(str).owl_defense_point = defense_point;
							  DRAGON2(str).owl_defense_code = dcode;
							  DRAGON2(str).owl_defense_kworm = kworm;
						  }
						  else {
							  /* Due to irregularities in the owl code, it may
							  * occasionally happen that a dragon is found to be
							  * attackable but also alive as it stands. In this case
							  * we still choose to say that the owl_status is
							  * CRITICAL, although we don't have any defense move to
							  * propose. Having the status right is important e.g.
							  * for connection moves to be properly valued.
							  */
							  DRAGON2(str).owl_status = (acode == GAIN ? ALIVE : CRITICAL);
							  DEBUG(DEBUG_OWL_PERFORMANCE,
								  "Inconsistent owl attack and defense results for %1m.\n", 
								  str);
							  /* Let's see whether the attacking move might be the right
							  * defense:
							  */
							  dcode = owl_does_defend(DRAGON2(str).owl_attack_point,
								  str, NULL);
							  if (dcode != 0) {
								  DRAGON2(str).owl_defense_point
									  = DRAGON2(str).owl_attack_point;
								  DRAGON2(str).owl_defense_code = dcode;
							  }
						  }
					  }
				  }
				  if (dcode == 0) {
					  DRAGON2(str).owl_status = DEAD; 
					  DRAGON2(str).owl_defense_point = NO_MOVE;
					  DRAGON2(str).owl_defense_code = 0;
				  }
			  }
			  else {
				  if (!DRAGON2(str).owl_attack_certain) {
					  kworm = NO_MOVE;
					  dcode = owl_defend(str, &defense_point, 
						  &DRAGON2(str).owl_defense_certain, &kworm);
					  if (dcode != 0) {
						  /* If the result of owl_attack was not certain, we may
						  * still want the result of owl_defend */
						  DRAGON2(str).owl_defense_point = defense_point;
						  DRAGON2(str).owl_defense_code = dcode;
						  DRAGON2(str).owl_defense_kworm = kworm;
					  }
				  }
				  DRAGON2(str).owl_status = ALIVE;
				  DRAGON2(str).owl_attack_point = NO_MOVE;
				  DRAGON2(str).owl_attack_code = 0;

			  }
		  }
	  }
	  time_report(2, "  owl reading", NO_MOVE, 1.0);
return;
// 
  /* Compute the status to be used by the matcher. We most trust the
   * owl status, if it is available. If it's not we assume that we are
   * already confident that the dragon is alive, regardless of
   * crude_status.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (IS_STONE(board[str])) {
      if (DRAGON2(str).owl_status != UNCHECKED)
	dragon[str].status = DRAGON2(str).owl_status;
      else
	dragon[str].status = ALIVE;
    }

  /* The dragon data is now correct at the origin of each dragon but
   * we need to copy it to every vertex.  
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str) && board[str] != EMPTY)
      dragon[str] = dragon[dragon[str].origin];

  identify_thrashing_dragons();
  
  /* Owl threats. */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str) 
	&& board[str] != EMPTY 
	&& dragon[str].origin == str) {
      struct eyevalue no_eyes;
      set_eyevalue(&no_eyes, 0, 0, 0, 0);
      if (crude_dragon_weakness(ALIVE, &no_eyes, 0,
	    			DRAGON2(str).moyo_territorial_value,
				DRAGON2(str).escape_route - 10)
	  < 0.00001 + gg_max(0.12, 0.32 - 0.01*dragon[str].effective_size)) {
	DRAGON2(str).owl_threat_status = UNCHECKED;
	DRAGON2(str).owl_second_attack_point  = NO_MOVE;
	DRAGON2(str).owl_second_defense_point = NO_MOVE;
      }
      else {
	int acode = DRAGON2(str).owl_attack_code;
	int dcode = DRAGON2(str).owl_defense_code;
	int defense_point, second_defense_point;

	if (get_level() >= 8
	    && !disable_threat_computation
	    && (owl_threats 
		|| thrashing_stone[str])) {
	  if (acode && !dcode && DRAGON2(str).owl_attack_point != NO_MOVE) {
	    if (owl_threaten_defense(str, &defense_point,
				     &second_defense_point)) {
	      DRAGON2(str).owl_threat_status = CAN_THREATEN_DEFENSE;
	      DRAGON2(str).owl_defense_point = defense_point;
	      DRAGON2(str).owl_second_defense_point = second_defense_point;
	    }
	    else
	      DRAGON2(str).owl_threat_status = DEAD;
	  }
	  else if (!acode) {
	    int attack_point, second_attack_point;
	    if (owl_threaten_attack(str, 
				    &attack_point, &second_attack_point)) {
	      DRAGON2(str).owl_threat_status = CAN_THREATEN_ATTACK;
	      DRAGON2(str).owl_attack_point = attack_point;
	      DRAGON2(str).owl_second_attack_point = second_attack_point;
	    }
	    else
	      DRAGON2(str).owl_threat_status = ALIVE;
	  }
	}
      }
    }
  
  /* Once again, the dragon data is now correct at the origin of each dragon
   * but we need to copy it to every vertex.  
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str) && board[str] != EMPTY)
      dragon[str] = dragon[dragon[str].origin];

  time_report(2, "  owl threats ", NO_MOVE, 1.0);
  

  /* Compute the safety value. */
  for (d = 0; d < number_of_dragons; d++) {
    int true_genus;
    int origin = dragon2[d].origin;
    struct eyevalue *genus = &dragon2[d].genus;

    /* FIXME: We lose information when constructing true_genus. This
     * code can be improved.
     */
    true_genus = max_eyes(genus) + min_eyes(genus);
    if (dragon_looks_inessential(origin))
      dragon2[d].safety = INESSENTIAL;
    else if (dragon[origin].size == worm[origin].size
	     && worm[origin].attack_codes[0] != 0
	     && worm[origin].defense_codes[0] == 0)
      dragon2[d].safety = TACTICALLY_DEAD;
    else if (0) /* Seki is detected by the call to semeai() below. */
      dragon2[d].safety = ALIVE_IN_SEKI;
    else if (dragon_invincible(origin)) {
      dragon2[d].safety = INVINCIBLE;
      /* Sometimes the owl analysis may have misevaluated invincible
       * dragons, typically if they live by topologically false eyes.
       * Therefore we also set the status here.
       */
      DRAGON(d).status = ALIVE;
    }
    else if (dragon2[d].owl_status == DEAD)
      dragon2[d].safety = DEAD;
    else if (dragon2[d].owl_status == CRITICAL)
      dragon2[d].safety = CRITICAL;
    else if (true_genus >= 6 || dragon2[d].moyo_size > 20)
      dragon2[d].safety = STRONGLY_ALIVE;
    else
      dragon2[d].safety = ALIVE;
  }

  /* The status is now correct at the origin of each dragon
   * but we need to copy it to every vertex.
   */
  for (str = BOARDMIN; str < BOARDMAX; str++)
    if (ON_BOARD(str))
      dragon[str].status = dragon[dragon[str].origin].status;

  /* Revise inessentiality of critical worms and dragons. */
  revise_inessentiality();

  semeai();
  time_report(2, "  semeai module", NO_MOVE, 1.0);
  
  /* Count the non-dead dragons. */
  lively_white_dragons = 0;
  lively_black_dragons = 0;
  for (d = 0; d < number_of_dragons; d++)
    if (DRAGON(d).status != DEAD) {
      if (DRAGON(d).color == WHITE)
        lively_white_dragons++;
      else
        lively_black_dragons++;
    }
}
/*
 * Examine the position and try to gather as much information as possible.
 * This is used mainly for move generation, but could also be called
 * for debugging purposes (decidestring, etc).
 *
 * The parameter how_much tells us how much of the work we have to do.
 * For move generation we have to do it all.  For debugging we can 
 * sometimes stop a little earlier.
 *
 * aftermath_play indicates we are in aftermath playout phase. It's only
 * effect is to always use chinese rules for the score estimates.
 */
void
examine_position1(int how_much, int aftermath_play)
{
  int save_verbose = verbose;

  purge_persistent_caches();
  
  /* Don't print reading traces during make_worms and make_dragons unless 
   * the user really wants it (verbose == 3). 
   */
  if (verbose == 1 || verbose == 2)
    --verbose;

  if (NEEDS_UPDATE(worms_examined)) {
    start_timer(0);
    make_worms();
    time_report(0, "  make worms", NO_MOVE, 1.0);
  }

  if (how_much == EXAMINE_WORMS) {
    verbose = save_verbose;
    gg_assert(test_gray_border() < 0);
    return;
  }

  if (stones_on_board(BLACK | WHITE) != 0) {
    if (NEEDS_UPDATE(initial_influence_examined))
      compute_worm_influence();
    if (how_much == EXAMINE_INITIAL_INFLUENCE) {
      verbose = save_verbose;
      gg_assert(test_gray_border() < 0);
      return;
    }

    if (how_much == EXAMINE_DRAGONS_WITHOUT_OWL) {
      if (NEEDS_UPDATE(dragons_examined_without_owl))
	make_dragons1(1);
      verbose = save_verbose;
      gg_assert(test_gray_border() < 0);
      return;
    }
    
    if (NEEDS_UPDATE(dragons_examined)) {
      make_dragons1(0);
	  //return;
	  //
      compute_scores(chinese_rules || aftermath_play);
      /* We have automatically done a partial dragon analysis as well. */
      dragons_examined_without_owl = position_number;
    }
    if (how_much == EXAMINE_DRAGONS) {
      verbose = save_verbose;
      gg_assert(test_gray_border() < 0);
      return;
    }
  }
  else if (how_much == EXAMINE_INITIAL_INFLUENCE
	   || how_much == EXAMINE_DRAGONS
	   || how_much == EXAMINE_ALL) {
    initialize_dragon_data();
    compute_scores(chinese_rules || aftermath_play);
    verbose = save_verbose;
    gg_assert(test_gray_border() < 0);
    return;
  }
 
  verbose = save_verbose;

  if (NEEDS_UPDATE(initial_influence2_examined)) {
    compute_dragon_influence();
  }
  if (how_much == EXAMINE_INITIAL_INFLUENCE2) {
    gg_assert(test_gray_border() < 0);
    return;
  }

  if (NEEDS_UPDATE(dragons_refinedly_examined)) {
    compute_refined_dragon_weaknesses();
    compute_strategic_sizes();
  }
  if (how_much == FULL_EXAMINE_DRAGONS) {
    gg_assert(test_gray_border() < 0);
    return;
  }

  if (printworms)
    show_dragons();
}



/* 
 * Perform the actual move generation.
 *
 * The array allowed_moves restricts which moves may be considered. If
 * NULL any move is allowed. Pass is always allowed and will be chosen
 * if the move generation doesn't like any of the allowed moves (or
 * overlooks them).
 */
  
static int
do_genmove(int color, float pure_threat_value,
	   int allowed_moves[BOARDMAX], float *value, int *resign)
{
  float average_score, pessimistic_score, optimistic_score;
  int save_verbose;
  int save_depth;
  int move;
  float dummy_value;
  int use_thrashing_dragon_heuristics = 0;

  if (!value)
    value = &dummy_value;

  start_timer(0);
  clearstats();

  /* Usually we would not recommend resignation. */
  if (resign)
    *resign = 0;
  
  /* Prepare our table of moves considered. */
  memset(potential_moves, 0, sizeof(potential_moves));
  
  /* no move is found yet. */
  move = PASS_MOVE;  
  *value = 0.0; 
  
  /* Prepare pattern matcher and reading code. */
  reset_engine();

  /* Store the depth value so we can check that it hasn't changed when
   * we leave this function.
   */
  save_depth = depth;

  /* If in mirror mode, try to find a mirror move. */
  //if (play_mirror_go
 //     && (mirror_stones_limit < 0
//	  || stones_on_board(WHITE | BLACK) <= mirror_stones_limit)
 //     && find_mirror_move(&move, color)) {
//    TRACE("genmove() recommends mirror move at %1m\n", move);
//    *value = 1.0;
//    return move;
//  }

  /* Find out information about the worms and dragons. */
  start_timer(1);
  examine_position(EXAMINE_ALL, 0);
  time_report(1, "examine position", NO_MOVE, 1.0);

  /* The score will be used to determine when we are safely
   * ahead. So we want the most conservative score.
   *
   * We always want to have the score from our point of view. So
   * negate it if we are black.
   */
  if (color == WHITE) {
    pessimistic_score = black_score;
    optimistic_score = white_score;
  }
  else {
    pessimistic_score = -white_score;
    optimistic_score = -black_score;
  }

  if (color == WHITE)
    average_score = (white_score + black_score)/2.0;
  else
    average_score = -(white_score + black_score)/2.0;
  choose_strategy(color, average_score, game_status(color));

  if (printboard) {
    if (printboard == 1)
      fprintf(stderr, "\n          dragon_status display:\n\n");
    if (printboard == 2)
      fprintf(stderr, "\n          eye display:\n\n");
    showboard(printboard); 
    if (printboard == 1) {
      fprintf(stderr, "\n           owl_status display:\n\n");      
      showboard(3);
      fprintf(stderr, "\n           matcher_status display:\n\n");      
      showboard(4);
    }
  }
  
  gg_assert(stackp == 0);
  
  /*
   * Ok, information gathering is complete. Now start to find some moves!
   */

  
  /* Pick up moves that we know of already. */
  save_verbose = verbose;
  if (verbose > 0)
    verbose--;
  collect_move_reasons(color);
  verbose = save_verbose;
  time_report(1, "generate move reasons", NO_MOVE, 1.0);
  
  /* Try to find empty corner moves. */
  fuseki(color);
  gg_assert(stackp == 0);

  /* Look for moves to break mirror play by the opponent. */
//  break_mirror_go(color);

  /* If we are ahead by 5 points or more, consider a thrashing
   * dragon dangerous and change its status from DEAD to
   * UNKNOWN. Otherwise, pretend there is no thrashing dragon.
   */
//  if (!doing_scoring)
//   use_thrashing_dragon_heuristics
//      = revise_thrashing_dragon(color, pessimistic_score, 5.0);
  
  /* The general pattern database. */
  shapes(color);
  time_report(1, "shapes", NO_MOVE, 1.0);
  gg_assert(stackp == 0);

  /* Look for combination attacks and defenses against them. */
  combinations(color);
  time_report(1, "combinations", NO_MOVE, 1.0);
  gg_assert(stackp == 0);

  /* Review the move reasons and estimate move values. */
  if (review_move_reasons(&move, value, color, 
			  pure_threat_value, pessimistic_score, allowed_moves,
			  use_thrashing_dragon_heuristics))
    TRACE("Move generation likes %1m with value %f\n", move, *value);
  gg_assert(stackp == 0);
  time_report(1, "review move reasons", NO_MOVE, 1.0);


  /* If the move value is 6 or lower, we look for endgame patterns too. */
  if (*value <= 6.0 && !disable_endgame_patterns) {
    endgame_shapes(color);
    endgame(color);
    gg_assert(stackp == 0);
    if (review_move_reasons(&move, value, color, pure_threat_value,
	  		    pessimistic_score, allowed_moves,
			    use_thrashing_dragon_heuristics))
      TRACE("Move generation likes %1m with value %f\n", move, *value);
    gg_assert(stackp == 0);
    time_report(1, "endgame", NO_MOVE, 1.0);
  }
  
  /* If no move found yet, revisit any semeai and change the
   * status of the opponent group from DEAD to UNKNOWN, then 
   * run shapes and endgame_shapes again. This may turn up a move.
   */
  if (move == PASS_MOVE) {
/*    if (revise_semeai(color)) {
      shapes(color);
      endgame_shapes(color);
      if (review_move_reasons(&move, value, color, pure_threat_value,
			      pessimistic_score, allowed_moves,
			      use_thrashing_dragon_heuristics)) {
	TRACE("Upon reconsideration move generation likes %1m with value %f\n",
	      move, *value); 
      }
    }
 */   time_report(1, "move reasons with revised semeai status",
		NO_MOVE, 1.0);
  }

  /* If Monte Carlo move generation is enabled, call it now. Do not
   * override a fuseki move.
   *
   * FIXME: Identifying fuseki moves by checking the move value is
   * very ugly and fragile.
   */
  if (use_monte_carlo_genmove && move != PASS_MOVE
      && (*value < 75.0 || *value > 75.01) && !doing_scoring) {
    int allowed_moves2[BOARDMAX];
    int num_allowed_moves2 = 0;
    int pos;
    for (pos = BOARDMIN; pos < BOARDMAX; pos++)
      if (ON_BOARD(pos)
	  && (!allowed_moves || allowed_moves[pos])
	  && is_allowed_move(pos, color)) {
	allowed_moves2[pos] = 1;
	num_allowed_moves2++;
      }
      else
	allowed_moves2[pos] = 0;
    
//    if (num_allowed_moves2 > 1)
//      move = monte_carlo_genmove(color, allowed_moves2, value, resign);
  }
  
  /* If still no move, fill a remaining liberty. This should pick up
   * all missing dame points.
   */
  if (move == PASS_MOVE
      && fill_liberty(&move, color)) {
    if (!allowed_moves || allowed_moves[move]) {
      *value = 1.0;
      TRACE("Filling a liberty at %1m\n", move);
      record_top_move(move, *value);
      move_considered(move, *value);
      time_report(1, "fill liberty", NO_MOVE, 1.0);
    }
    else
      move = PASS_MOVE;
  }

  /* If we're instructed to play out the aftermath or capture all dead
   * opponent stones, or if the opponent is trying to live inside
   * our territory and we are clearly ahead, generate an aftermath move.
   */
  if (move == PASS_MOVE) {
    if (play_out_aftermath 
	|| capture_all_dead 
	|| (!doing_scoring && thrashing_dragon && pessimistic_score > 15.0))
      move = aftermath_genmove(color, capture_all_dead, allowed_moves);

    if (move != PASS_MOVE) {
      ASSERT1(is_legal(move, color), move);
      *value = 1.0;
      TRACE("Aftermath move at %1m\n", move);
      record_top_move(move, *value);
      move_considered(move, *value);
      time_report(1, "aftermath_genmove", NO_MOVE, 1.0);
    }
  }

  /* If we somehow have managed to generate an illegal move, pass instead. */
  if (!is_allowed_move(move, color)) {
    TRACE("ILLEGAL MOVE GENERATED. Passing instead.\n");
    move = PASS_MOVE;
    *value = -1.0;
  }
  
  /* If no move is found then pass. */
  if (move == PASS_MOVE) {
    TRACE("I pass.\n");
  }
  else {
    TRACE("genmove() recommends %1m with value %f\n", move, *value);
  }
  
  /* Maybe time to resign...
   */
  if (resign && resign_allowed
      && *value < 10.0 /*&& should_resign(color, optimistic_score, move)*/) {
    TRACE("... though, genmove() thinks the position is hopeless\n");
    *resign = 1;
  }
  
  /* If statistics is turned on, this is the place to show it. */
  if (showstatistics)
    showstats();

  if (showtime) {
    double spent = time_report(0, "TIME to generate move at ", move, 1.0);
    total_time += spent;
    if (spent > slowest_time) {
      slowest_time = spent;
      slowest_move = move;
      slowest_movenum = movenum + 1;
    }
  }

  /* Some consistency checks to verify that things are properly
   * restored and/or have not been corrupted.
   */
  gg_assert(stackp == 0);
  gg_assert(test_gray_border() < 0);
  gg_assert(depth == save_depth);


  return move;
}

