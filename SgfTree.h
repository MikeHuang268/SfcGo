#pragma once



#include <stdio.h>


/* This is the Microsoft Visual C++ version of config.h        *
 * Replace the distributed config.h with this file             *
 * See config.h.in for comments on the meanings of most of the *
 * defines.  This file is autogenerated.  Do not modify it.    *
 * See instead, the perl script makevcdist.pl                  */

#define HAVE_CRTDBG_H 1
#define HAVE_WINSOCK_IO_H 1
#define HAVE__VSNPRINTF 1

 /* Connection module. Default standard. */
#define ALTERNATE_CONNECTIONS 1

/* Ruleset. Default Japanese */
#define CHINESE_RULES 0

/* Center oriented influence. Disabled by default. */
#define COSMIC_GNUGO 0

/* Default level (strength). Up to 10 supported */
#define DEFAULT_LEVEL 10

/* Default hash table size in megabytes */
#define DEFAULT_MEMORY 8

/* Compile support for GTP communication over TCP/IP channel. */
#define ENABLE_SOCKET_SUPPORT 1

/* Connection module. Default experimental. */
#define EXPERIMENTAL_CONNECTIONS 1

/* GAIN/LOSS codes. Disabled by default. */
#define EXPERIMENTAL_OWL_EXT 0

/* Define as 1 to use the grid optimisation, or 2 to run it in self-test mode
   */
#define GRID_OPT 1

   /* Large Scale Captures. Disabled by default. */
#define LARGE_SCALE 0

/* Oracle. Default not enabled. */
#define ORACLE 0

/* Owl Node Limit */
#define OWL_NODE_LIMIT 1000

/* Owl Threats. 0 standard. */
#define OWL_THREATS 0

/* Enable GNU Readline support */
#define READLINE 0

/* Allow resignation. Default enabled */
#define RESIGNATION_ALLOWED 1

/* Semeai Variations. 500 default */
#define SEMEAI_NODE_LIMIT 500

/* Break-in module. Enabled by default. */
#define USE_BREAK_IN 1

/* Define special valgrind macros. */
#define USE_VALGRIND 0


/* Version number of package */
#define PACKAGE "gnugo"

/* The concatenation of the strings "GNU ", and PACKAGE.  */
#define GNU_PACKAGE "GNU " PACKAGE

/* The number of bytes in a int.  */
#define SIZEOF_INT 4

/* The number of bytes in a long.  */
#define SIZEOF_LONG 4

/* Version number of package */
#define VERSION "1.0"

#pragma warning(disable: 4244 4305)
/* # */
/* # This document was taken from the SGF Specfication. See: */
/* # http://www.red-bean.com/sgf/ */
/* # */
/* # [SGF FF[4] - Smart Game Format] */
/* # */
/* # FF[4] property index */
/* # */
/* # This is an alphabetical index to all properties defined in FF[4]. */
/* # New properties are marked with '*', changed properties are marked with '!'. */
/* # */
/* #ID   Description     property type    property value */
/* #---- --------------- ---------------  -------------------------------------- */
     /*  Add Black       setup            list of stone */
#define SGFAB   16961
     /*  Add Empty       setup            list of point */
#define SGFAE   17729
     /*  Annotation      game-info        simpletext */
#define SGFAN   20033
     /*  Application     root             composed simpletext ':' simpletext */
#define SGFAP   20545
     /*  Arrow           -                list of composed point ':' point */
#define SGFAR   21057
     /*  Who adds stones - (LOA)          simpletext */
#define SGFAS   21313
     /*  Add White       setup            list of stone */
#define SGFAW   22337
     /*  Black           move             move */
#define SGFB     8258
     /*  Black time left move             real */
#define SGFBL   19522
     /*  Bad move        move             double */
#define SGFBM   19778
     /*  Black rank      game-info        simpletext */
#define SGFBR   21058
     /*  Black team      game-info        simpletext */
#define SGFBT   21570
     /*  Comment         -                text */
#define SGFC     8259
     /*  Charset         root             simpletext */
#define SGFCA   16707
     /*  Copyright       game-info        simpletext */
#define SGFCP   20547
     /*  Circle          -                list of point */
#define SGFCR   21059
     /*  Dim points      - (inherit)      elist of point */
#define SGFDD   17476
     /*  Even position   -                double */
#define SGFDM   19780
     /*  Doubtful        move             none */
#define SGFDO   20292
     /*  Date            game-info        simpletext */
#define SGFDT   21572
     /*  Event           game-info        simpletext */
#define SGFEV   22085
     /*  Fileformat      root             number (range: 1-4) */
#define SGFFF   17990
     /*  Figure          -                none | composed number ":" simpletext */
#define SGFFG   18246
     /*  Good for Black  -                double */
#define SGFGB   16967
     /*  Game comment    game-info        text */
#define SGFGC   17223
     /*  Game            root             number (range: 1-5,7-16) */
#define SGFGM   19783
     /*  Game name       game-info        simpletext */
#define SGFGN   20039
     /*  Good for White  -                double */
#define SGFGW   22343
     /*  Handicap        game-info (Go)   number */
#define SGFHA   16712
     /*  Hotspot         -                double */
#define SGFHO   20296
     /*  Initial pos.    game-info (LOA)  simpletext */
#define SGFIP   20553
     /*  Interesting     move             none */
#define SGFIT   21577
     /*  Invert Y-axis   game-info (LOA)  simpletext */
#define SGFIY   22857
     /*  Komi            game-info (Go)   real */
#define SGFKM   19787
     /*  Ko              move             none */
#define SGFKO   20299
     /*  Label           -                list of composed point ':' simpletext */
#define SGFLB   16972
     /*  Line            -                list of composed point ':' point */
#define SGFLN   20044
     /*  Mark            -                list of point */
#define SGFMA   16717
     /*  set move number move             number */
#define SGFMN   20045
     /*  Nodename        -                simpletext */
#define SGFN     8270
     /*  OtStones Black  move             number */
#define SGFOB   16975
     /*  Opening         game-info        text */
#define SGFON   20047
     /*  Overtime        game-info        simpletext */
#define SGFOT   21583
     /*  OtStones White  move             number */
#define SGFOW   22351
     /*  Player Black    game-info        simpletext */
#define SGFPB   16976
     /*  Place           game-info        simpletext */
#define SGFPC   17232
     /*  Player to play  setup            color */
#define SGFPL   19536
     /*  Print move mode - (inherit)      number */
#define SGFPM   19792
     /*  Player White    game-info        simpletext */
#define SGFPW   22352
     /*  Result          game-info        simpletext */
#define SGFRE   17746
     /*  Round           game-info        simpletext */
#define SGFRO   20306
     /*  Rules           game-info        simpletext */
#define SGFRU   21842
     /*  Markup          - (LOA)          point */
#define SGFSE   17747
     /*  Selected        -                list of point */
#define SGFSL   19539
     /*  Source          game-info        simpletext */
#define SGFSO   20307
     /*  Square          -                list of point */
#define SGFSQ   20819
     /*  Style           root             number (range: 0-3) */
#define SGFST   21587
     /*  Setup type      game-info (LOA)  simpletext */
#define SGFSU   21843
     /*  Size            root             (number | composed number ':' number) */
#define SGFSZ   23123
     /*  Territory Black - (Go)           elist of point */
#define SGFTB   16980
     /*  Tesuji          move             double */
#define SGFTE   17748
     /*  Timelimit       game-info        real */
#define SGFTM   19796
     /*  Triangle        -                list of point */
#define SGFTR   21076
     /*  Territory White - (Go)           elist of point */
#define SGFTW   22356
     /*  Unclear pos     -                double */
#define SGFUC   17237
     /*  User            game-info        simpletext */
#define SGFUS   21333
     /*  Value           -                real */
#define SGFV     8278
     /*  View            - (inherit)      elist of point */
#define SGFVW   22358
     /*  White           move             move */
#define SGFW     8279
     /*  White time left move             real */
#define SGFWL   19543
     /*  White rank      game-info        simpletext */
#define SGFWR   21079
     /*  White team      game-info        simpletext */
#define SGFWT   21591
     /*  Move score      move             double */
#define SGFMS   21325
     /*  Move standard score move         double */
#define SGFSS   21331
     /*  Period time     move             double */
#define SGFPT   21584
/* # */
/* # These are additions to the SGF spec- old commands and some others */
/* # */

/* # */
/* # outdated FF3 properties */
/* # */
#define SGFBS 21314
#define SGFWS 21335
#define SGFID 17481
#define SGFRG 18258
#define SGFSC 17235

/* # */
/* # some random ones used by CGoban */
/* # */
#define SGFSY 22867

/* # */
/* # nonstandard SGF property used by GNU Go to mark illegal moves */
/* # */
#define SGFIL 19529

//#ifndef _SGFTREE_H_
#define _SGFTREE_H_

#ifndef _BOARD_H_
/*
 * NOTE: These MUST coincide with the definitions for the engine that we
 *       are using. In this case they are defined in engine/gnugo.h.
 *
 * The reason that we put them here within the #ifndef clause is because
 * we want to decouple the GNU Go engine from SGF library, but we don't
 * want to redefine these symbols if we include this file into board.h.
 */

#define EMPTY 0
#define WHITE 1
#define BLACK 2
#endif

#ifndef _RANDOM_H_
#define _RANDOM_H_

//random
/* Internal state of the random number generator. */
struct gg_rand_state {
    unsigned int x[25];   /* Internal state. */
    int k;                /* Word counter. */
};

/* Seed the random number generator. If an unsigned int is larger than
 * 32 bits, only the 32 least significant bits are used for seeding.
 */
void gg_srand(unsigned int seed);

/* Obtain one random integer value in the interval [0, 2^31-1]. */
int gg_rand(void);

/* Obtain one random integer value in the interval [0, 2^32-1]. */
unsigned int gg_urand(void);

/* Obtain one random floating point value in the half open interval
 * [0.0, 1.0).
 *
 * If the value is converted to a floating point type with less than
 * 32 bits mantissa (or if the double type should happen to be
 * unusually short), the value 1.0 may be attained.
 */
double gg_drand(void);

/* Retrieve the internal state of the random generator. */
void gg_get_rand_state(struct gg_rand_state* state);

/* Set the internal state of the random number generator. */
void gg_set_rand_state(struct gg_rand_state* state);


#endif /* _RANDOM_H_ */


/*
 * Local Variables:
 * tab-width: 8
 * c-basic-offset: 2
 * End:
 */


 //gg_utils
void gg_init_color(void);
void write_color_char(int c, int x);
void write_color_string(int c, const char* str);

void gg_vsnprintf(char* dest, unsigned long len, const char* fmt,
    va_list args);
void gg_snprintf(char* dest, unsigned long len, const char* fmt, ...);

double gg_gettimeofday(void);
double gg_cputime(void);

float gg_normalize_float(float x, float a);
int gg_normalize_float2int(float x, float a);
void gg_sort(void* base, size_t nel, size_t width,
    int (*compar)(const void*, const void*));

#define MAX_INTERPOLATION_STEPS 20
struct interpolation_data
{
    int sections;
    float range_lowerbound;
    float range_upperbound;
    float values[MAX_INTERPOLATION_STEPS + 1];
};

float gg_interpolate(struct interpolation_data* f, float x);
float soft_cap(float a, float b);

const char* gg_version(void);

/* prototypes for basic reorientation functions */

void rotate(int i, int j, int* ri, int* rj, int bs, int rot);
void inv_rotate(int i, int j, int* ri, int* rj, int bs, int rot);

void update_random_seed(void);
void set_random_seed(unsigned int seed);
unsigned int get_random_seed(void);
void reuse_random_seed(void);


//#endif /* _GG_UTILS_H_ */


//sgftree
void* xalloc(unsigned int);

/*
 * A property of an SGF node.  An SGF node is described by a linked
 * list of these.
 */

typedef struct SGFProperty_t {
	struct SGFProperty_t* next;
	short name;
	char* value;
} SGFProperty;


typedef struct SGFNode_t {
	SGFProperty* props;
	struct SGFNode_t* parent;
	struct SGFNode_t* child;
	struct SGFNode_t* next;
} SGFNode;


/* low level functions */
SGFNode* sgfPrev(SGFNode* node);
SGFNode* sgfRoot(SGFNode* node);
SGFNode* sgfNewNode(void);
void sgfFreeNode(SGFNode* node);

int sgfGetIntProperty(SGFNode* node, const char* name, int* value);
int sgfGetFloatProperty(SGFNode* node, const char* name, float* value);
int sgfGetCharProperty(SGFNode* node, const char* name, char** value);
void sgfAddProperty(SGFNode* node, const char* name, const char* value);
void sgfAddPropertyInt(SGFNode* node, const char* name, long val);
void sgfAddPropertyFloat(SGFNode* node, const char* name, float val);
void sgfOverwriteProperty(SGFNode* node, const char* name, const char* text);
void sgfOverwritePropertyFloat(SGFNode* node, const char* name, float val);
void sgfOverwritePropertyInt(SGFNode* node, const char* name, int val);
void* xrealloc(void* pt, unsigned int size);
SGFProperty* sgfMkProperty(const char* name, const  char* value,
	SGFNode* node, SGFProperty* last);
void sgfFreeProperty(SGFProperty* prop);

SGFNode* sgfAddStone(SGFNode* node, int color, int movex, int movey);
SGFNode* sgfAddPlay(SGFNode* node, int who, int movex, int movey);
SGFNode* sgfAddPlayLast(SGFNode* node, int who, int movex, int movey);

void sgfWriteResult(SGFNode* node, float score, int overwrite);
void sgf_write_header(SGFNode* root, int overwrite, int seed, float komi,
	int handicap, int level, int rules);

SGFNode* sgfLabel(SGFNode* node, const char* label, int i, int j);
SGFNode* sgfLabelInt(SGFNode* node, int num, int i, int j);
SGFNode* sgfCircle(SGFNode* node, int i, int j);
SGFNode* sgfSquare(SGFNode* node, int i, int j);
SGFNode* sgfTriangle(SGFNode* node, int i, int j);
SGFNode* sgfMark(SGFNode* node, int i, int j);
SGFNode* sgfAddComment(SGFNode* node, const char* comment);
SGFNode* sgfBoardText(SGFNode* node, int i, int j, const char* text);
SGFNode* sgfBoardChar(SGFNode* node, int i, int j, char c);
SGFNode* sgfBoardNumber(SGFNode* node, int i, int j, int number);
SGFNode* sgfStartVariant(SGFNode* node);
SGFNode* sgfStartVariantFirst(SGFNode* node);
SGFNode* sgfAddChild(SGFNode* node);

SGFNode* sgfCreateHeaderNode(int boardsize, float komi, int handicap);

/* Read SGF tree from file. */
SGFNode* readsgffile(const char* filename);
/* Specific solution for fuseki */
SGFNode* readsgffilefuseki(const char* filename, int moves_per_game);

/* Write SGF tree to a file. */
int writesgf(SGFNode* root, const char* filename);


/* ---------------------------------------------------------------- */
/* ---                          SGFTree                         --- */
/* ---------------------------------------------------------------- */


typedef struct SGFTree_t {
	SGFNode* root;
	SGFNode* lastnode;
} SGFTree;


void sgftree_clear(SGFTree* tree);
int sgftree_readfile(SGFTree* tree, const char* infilename);

int sgftreeBack(SGFTree* tree);
int sgftreeForward(SGFTree* tree);

void sgftreeAddPlay(SGFTree* tree, int color, int movex, int movey);
void sgftreeAddPlayLast(SGFTree* tree, int color, int movex, int movey);
void sgftreeAddStone(SGFTree* tree, int color, int movex, int movey);
void sgftreeWriteResult(SGFTree* tree, float score, int overwrite);
SGFNode* sgftreeNodeCheck(SGFTree* tree);

void sgftreeCircle(SGFTree* tree, int i, int j);
void sgftreeSquare(SGFTree* tree, int i, int j);
void sgftreeTriangle(SGFTree* tree, int i, int j);
void sgftreeMark(SGFTree* tree, int i, int j);
void sgftreeAddComment(SGFTree* tree, const char* comment);
void sgftreeBoardText(SGFTree* tree, int i, int j, const char* text);
void sgftreeBoardChar(SGFTree* tree, int i, int j, char c);
void sgftreeBoardNumber(SGFTree* tree, int i, int j, int number);
void sgftreeStartVariant(SGFTree* tree);
void sgftreeStartVariantFirst(SGFTree* tree);
void sgftreeCreateHeaderNode(SGFTree* tree, int boardsize, float komi,
	int handicap);
void sgftreeSetLastNode(SGFTree* tree, SGFNode* lastnode);


/* ---------------------------------------------------------------- */
/* ---                         Utilities                        --- */
/* ---------------------------------------------------------------- */


int get_moveX(SGFProperty* property, int boardsize);
int get_moveY(SGFProperty* property, int boardsize);
int get_moveXY(SGFProperty* property, int* i, int* j, int boardsize);

int show_sgf_properties(SGFNode* node);
int show_sgf_tree(SGFNode* node);
int is_markup_node(SGFNode* node);
int is_move_node(SGFNode* node);
int is_pass_node(SGFNode* node, int boardsize);
int find_move(SGFNode* node);


//#endif

